<!DOCTYPE html>
<html>
<head>
    <title>Triton Flash & Configure</title>
    <script type="module" src="https://unpkg.com/esp-web-tools@10/dist/web/install-button.js?module"></script>
    <style>
        body { font-family: sans-serif; padding: 2rem; }
        .hidden { display: none; }
        button { padding: 10px 20px; font-size: 16px; margin-top: 20px; cursor: pointer; }
    </style>
</head>
<body>
    <h1>Triton v8.4 Flasher</h1>

    <!-- Step 1: Flash Firmware -->
<div id="flash-section">
        <esp-web-install-button
            manifest="manifest.json"
        ></esp-web-install-button>
    </div>

    <button id="btn-force-show" style="margin-top: 40px; background: #f0f0f0; color: #666; font-size: 0.8em; border: 1px solid #ccc;">
        ⚠️ Manuelle Konfiguration öffnen (falls Popup fehlt)
    </button>

    <div id="config-section" class="hidden">
        <h2>Configuration</h2>
        <p>Firmware installed. Now configure the device.</p>

        <label>Tenant ID (Auto): <input type="text" id="tid" readonly></label><br><br>
        <label>Claim PIN (Auto): <input type="text" id="pin" readonly></label><br><br>
        <label>DB Secret: <input type="password" id="secret"></label><br><br>
        <label>Firebase Host: <input type="text" id="host"></label><br><br>
        <label>WiFi SSID: <input type="text" id="ssid"></label><br><br>
        <label>WiFi Password: <input type="password" id="pass"></label><br><br>

        <button id="btn-configure">Configure Device</button>
        <div id="status"></div>
    </div>

<script>
    // Warten, bis die Seite komplett geladen ist
    document.addEventListener('DOMContentLoaded', () => {
        // KORREKTE Selektoren für die tatsächlichen HTML-Elemente
        const installButton = document.querySelector('esp-web-install-button');
        const configSection = document.getElementById('config-section');
        const btnForceShow = document.getElementById('btn-force-show');
        const sendConfigBtn = document.getElementById('btn-configure');
        const statusDiv = document.getElementById('status');

        // IDs generieren
        const tidValue = "dev_" + Math.random().toString(36).substring(2, 8);
        const pinValue = Math.floor(100000 + Math.random() * 900000);
        document.getElementById('tid').value = tidValue;
        document.getElementById('pin').value = pinValue;

        // Flash-Status überwachen
        if (installButton) {
            installButton.addEventListener('state-change', (ev) => {
                const state = ev.detail.state;
                console.log('Install State:', state);

                // Config-Bereich anzeigen wenn Flash erfolgreich
                if (state === 'INSTALL_SUCCESSFUL' || state === 'IMPROV_SUCCESSFUL' ||
                    (state && state.includes('SUCCESS')) || state === 'ERROR') {
                    configSection.classList.remove('hidden');
                    btnForceShow.style.display = 'none';
                }
            });
        }

        // Manueller Button zum Öffnen der Konfiguration
        btnForceShow.addEventListener('click', () => {
            configSection.classList.remove('hidden');
            btnForceShow.style.display = 'none';
        });

        // --- HAUPTFUNKTION: KONFIGURATION SENDEN ---
        sendConfigBtn.addEventListener('click', async () => {
            // Validierung zuerst
            const tid = document.getElementById('tid').value;
            const pin = document.getElementById('pin').value;
            const secret = document.getElementById('secret').value;
            const host = document.getElementById('host').value;
            const ssid = document.getElementById('ssid').value;
            const pass = document.getElementById('pass').value;

            if (!secret || !host || !ssid || !pass) {
                statusDiv.innerText = "Fehler: Bitte alle Felder ausfüllen (SSID, Pass, Secret, Host).";
                statusDiv.style.color = "red";
                return;
            }

            statusDiv.innerText = "Starte Verbindung... Bitte Gerät im Popup auswählen.";
            statusDiv.style.color = "blue";

            let port = null;
            let writer = null;

            try {
                // 1. PORT ERZWINGEN: Der User MUSS neu auswählen.
                port = await navigator.serial.requestPort();

                // 2. PORT ÖFFNEN
                // WICHTIG: KEINE DTR/RTS Flags setzen!
                // Bei ESP32-C3 USB-CDC lösen diese einen RESET aus!
                statusDiv.innerText = "Öffne Port...";
                await port.open({ baudRate: 115200 });

                // Warte bis Port stabil ist
                await new Promise(r => setTimeout(r, 100));

                // 3. DATEN VORBEREITEN
                // Format: TenantID|PIN|Secret|Host|SSID|Pass
                const dataStr = `${tid}|${pin}|${secret}|${host}|${ssid}|${pass}`;
                const encoder = new TextEncoder();
                const dataBytes = encoder.encode(dataStr);
                const len = dataBytes.length;

                // Checksumme: (0x04 + Len + Sum(Data)) & 0xFF
                let sum = 0x04 + len;
                for (let b of dataBytes) sum += b;
                const checksum = sum & 0xFF;

                // Paket: [0x04, Len, ...Data, Checksum]
                const packet = new Uint8Array(2 + len + 1);
                packet[0] = 0x04;
                packet[1] = len;
                packet.set(dataBytes, 2);
                packet[len + 2] = checksum;

                console.log("Sende Paket (hex):", Array.from(packet).map(b => b.toString(16).padStart(2, '0')).join(' '));
                console.log("Daten-String:", dataStr);
                console.log("Länge:", len, "Checksumme:", checksum.toString(16));
                statusDiv.innerText = `Sende ${packet.length} Bytes...`;

                // 4. SENDEN
                writer = port.writable.getWriter();
                await writer.write(packet);

                // Warte kurz damit Daten rausgehen
                await new Promise(r => setTimeout(r, 50));

                writer.releaseLock();
                writer = null;

                // 5. OPTIONAL: Auf Antwort warten (für Debugging)
                statusDiv.innerText = "Gesendet! Warte auf Antwort...";

                const reader = port.readable.getReader();
                let response = "";
                const timeout = setTimeout(() => reader.cancel(), 2000);

                try {
                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;
                        if (value) {
                            const text = new TextDecoder().decode(value);
                            response += text;
                            console.log("Empfangen:", text);
                            // Wenn wir was empfangen haben, kurz warten und dann beenden
                            if (response.length > 0) {
                                await new Promise(r => setTimeout(r, 500));
                                break;
                            }
                        }
                    }
                } catch (e) {
                    // Timeout oder cancel - ist OK
                }
                clearTimeout(timeout);
                reader.releaseLock();

                if (response.length > 0) {
                    console.log("Gesamte Antwort:", response);
                    statusDiv.innerText = "Konfiguration GESENDET! Gerät antwortet. Neustart...";
                } else {
                    statusDiv.innerText = "Konfiguration gesendet (keine Antwort). Prüfe Gerät-Logs.";
                }
                statusDiv.style.color = "green";

            } catch (err) {
                console.error("Serial Error:", err);

                // Spezifische Fehlermeldungen
                if (err.name === 'NotFoundError') {
                    statusDiv.innerText = "Fehler: Kein Gerät ausgewählt.";
                } else if (err.name === 'NetworkError' || err.message.includes('busy')) {
                    statusDiv.innerText = "Fehler: Port belegt. Gerät abstecken und erneut versuchen.";
                } else if (err.name === 'InvalidStateError') {
                    statusDiv.innerText = "Fehler: Port bereits geöffnet. Seite neu laden.";
                } else {
                    statusDiv.innerText = "Fehler: " + err.message;
                }
                statusDiv.style.color = "red";

                if (writer) {
                    try { writer.releaseLock(); } catch (e) {}
                }
            } finally {
                // 6. PORT IMMER SCHLIESSEN
                if (port) {
                    try {
                        await port.close();
                        console.log("Port geschlossen.");
                    } catch (e) {
                        // Ignorieren - Port könnte schon zu sein
                    }
                }
            }
        });
    });
</script>
</body>
</html>
